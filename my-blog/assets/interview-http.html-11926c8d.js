import{_ as a,p as h,q as r,s as i,R as e,t as d,a2 as o,Y as l,n}from"./framework-e1bed10d.js";const T={},s=l('<h1 id="「面试」http" tabindex="-1"><a class="header-anchor" href="#「面试」http" aria-hidden="true">#</a> 「面试」Http</h1><h2 id="http协议的特点" tabindex="-1"><a class="header-anchor" href="#http协议的特点" aria-hidden="true">#</a> HTTP协议的特点</h2><ul><li>无连接：连接一次就会断开，不会保持连接</li><li>无状态：但从HTTP协议不能够区分两次连接者的身份</li><li>简单快速：每个资源（统一资源符）都是固定的</li><li>灵活：通过一个HTTP协议就可以完成不同数据类型的传输</li></ul><h2 id="http报文的组成部分" tabindex="-1"><a class="header-anchor" href="#http报文的组成部分" aria-hidden="true">#</a> HTTP报文的组成部分</h2><ul><li>请求报文 <ul><li>请求行：包含HTTP方法、页面地址、HTTP协议、版本</li><li>请求头：一些key-value值来告诉服务端我要那些内容，要用什么类型</li><li>空行：告诉服务端下一行为请求体</li><li>请求体</li></ul></li><li>响应报文 <ul><li>响应行</li><li>响应头</li><li>空行</li><li>请求体</li></ul></li></ul><h2 id="http方法" tabindex="-1"><a class="header-anchor" href="#http方法" aria-hidden="true">#</a> HTTP方法</h2><ul><li>GET：获取资源</li><li>POST：传输资源</li><li>PUT：更新资源</li><li>DELETE：删除资源</li><li>HEAD：获得报文首部</li></ul><h2 id="get和post的区别" tabindex="-1"><a class="header-anchor" href="#get和post的区别" aria-hidden="true">#</a> GET和POST的区别</h2><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求</li><li>GET产生的URL地址可以被收藏，而POST不可以</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置</li><li>GET请求只能进行ur|编码，而POST支持多种编码方式</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有限制</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li><li>GET参数通过URL传递，POST放在Request body中</li></ul>',9),c={id:"http状态码",tabindex:"-1"},u=i("a",{class:"header-anchor",href:"#http状态码","aria-hidden":"true"},"#",-1),p=l('<h2 id="http持久连接" tabindex="-1"><a class="header-anchor" href="#http持久连接" aria-hidden="true">#</a> HTTP持久连接</h2><p>HTTP协议采用“请求-应答&quot;模式，当使用普通模式，即非Keep-Alive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接(HTTP协议为无连接的协议)<br> 当使用Keep-Alive模式(又称持久连接、连接重用)时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接</p><blockquote><p>自1.1开始支持</p></blockquote><h2 id="管线化" tabindex="-1"><a class="header-anchor" href="#管线化" aria-hidden="true">#</a> 管线化</h2><p>使用持久连接的情况下，某个连接上消息的传递类似于<code>请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3</code><br> 管线化情况下，某个连接_上的消息变成了类似这样<code>请求1 -&gt;请求2-&gt;请求3-&gt;响应1 -&gt;响应2 -&gt;响应3</code></p><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h3><ul><li>管线化机制通过持久连接完成，仅HTTP/1.1支持此技术</li><li>只有GET和HEAD请求可以进行管线化，而POST则有所限制</li><li>初次创建连接时不应启动管线机制，因为对方(服务器)不一定支持HTTP/1.1版本的协议</li><li>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</li><li>HTTP/1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li><li>由于.上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如Chrome和Firefox默认并未开启管线化支持</li></ul>',7);function P(_,H){const t=n("RouterLink");return h(),r("div",null,[s,i("h2",c,[u,e(),d(t,{to:"/blogs/beginner-notes/Notes-Http-code.html"},{default:o(()=>[e("HTTP状态码")]),_:1})]),p])}const E=a(T,[["render",P],["__file","interview-http.html.vue"]]);export{E as default};
