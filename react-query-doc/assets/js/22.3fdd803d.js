(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{349:function(t,e,a){"use strict";a.r(e);var v=a(7),n=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"usequery"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usequery"}},[t._v("#")]),t._v(" useQuery")]),t._v(" "),a("div",{staticClass:"language-tsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-tsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  dataUpdatedAt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  error"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  errorUpdatedAt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  failureCount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  failureReason"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isError"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isFetched"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isFetchedAfterMount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isFetching"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isPaused"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isLoading"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isLoadingError"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isPlaceholderData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isPreviousData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isRefetchError"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isRefetching"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isInitialLoading"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isStale"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  isSuccess"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  refetch"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  remove"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  status"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  fetchStatus"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useQuery")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  queryKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  queryFn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  cacheTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  enabled"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  networkMode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  initialData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  initialDataUpdatedAt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  keepPreviousData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  meta"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  notifyOnChangeProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  onError"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  onSettled"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  onSuccess"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  placeholderData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  queryKeyHashFn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  refetchInterval"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  refetchIntervalInBackground"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  refetchOnMount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  refetchOnReconnect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  refetchOnWindowFocus"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  retry"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  retryOnMount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  retryDelay"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  select"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  staleTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  structuralSharing"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  suspense"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  useErrorBoundary"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[a("strong",[t._v("选项")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("queryKey: unknown[]")]),t._v(" "),a("ul",[a("li",[t._v("必需")]),t._v(" "),a("li",[t._v("用于此查询的查询键。")]),t._v(" "),a("li",[t._v("查询键将被散列成一个稳定的散列。有关详细信息，请参阅查询键。")]),t._v(" "),a("li",[t._v("当此键更改时，查询将自动更新（只要 enabled 未设置为 false）。")])])]),t._v(" "),a("li",[a("code",[t._v("queryFn: (context: QueryFunctionContext) => Promise<TData>")]),t._v(" "),a("ul",[a("li",[t._v("必需，但前提是未定义默认查询函数。有关详细信息，请参阅默认查询函数。")]),t._v(" "),a("li",[t._v("查询将用于请求数据的函数。")]),t._v(" "),a("li",[t._v("接收 QueryFunctionContext")]),t._v(" "),a("li",[t._v("必须返回一个将解析数据或抛出错误的承诺。数据不能未定义。")])])]),t._v(" "),a("li",[a("code",[t._v("enabled:boolean")]),t._v(" "),a("ul",[a("li",[t._v("将此设置为 false 以禁止此查询自动运行。")]),t._v(" "),a("li",[t._v("可用于相关查询。")])])]),t._v(" "),a("li",[a("code",[t._v("networkMode: 'online' | 'always' | 'offlineFirst")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("默认为“在线”")]),t._v(" "),a("li",[t._v("有关详细信息，请参阅网络模式。")])])]),t._v(" "),a("li",[a("code",[t._v("retry: boolean | number | (failureCount: number, error: TError) => boolean")]),t._v(" "),a("ul",[a("li",[t._v("如果为 false，失败的查询默认不会重试。")]),t._v(" "),a("li",[t._v("如果为真，失败的查询将无限重试。")]),t._v(" "),a("li",[t._v("如果设置为数字，例如3、失败的查询会重试，直到失败的查询计数满足那个数。")])])]),t._v(" "),a("li",[a("code",[t._v("retryOnMount:boolean")]),t._v(" "),a("ul",[a("li",[t._v("如果设置为 false，如果查询包含错误，则不会在挂载时重试。默认为真。")])])]),t._v(" "),a("li",[a("code",[t._v("retryDelay:number | (retryAttempt: number, error: TError) => number")]),t._v(" "),a("ul",[a("li",[t._v("此函数接收一个 retryAttempt 整数和实际错误，并返回在下一次尝试之前应用的延迟（以毫秒为单位）。")]),t._v(" "),a("li",[t._v("像 attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000) 这样的函数应用指数退避。")]),t._v(" "),a("li",[t._v("像 attempt => attempt * 1000 这样的函数应用线性退避。")])])]),t._v(" "),a("li",[a("code",[t._v("staleTime: number |Infinity")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("默认为 0")]),t._v(" "),a("li",[t._v("数据被认为过时后的时间（以毫秒为单位）。该值仅适用于定义它的挂钩。")]),t._v(" "),a("li",[t._v("如果设置为 Infinity，数据将永远不会被认为是陈旧的")])])]),t._v(" "),a("li",[a("code",[t._v("cacheTime:number |Infinity")]),t._v(" "),a("ul",[a("li",[t._v("在 SSR 期间默认为 5 * 60 * 1000（5 分钟）或无限")]),t._v(" "),a("li",[t._v("未使用/非活动缓存数据保留在内存中的时间（以毫秒为单位）。当查询的缓存变为未使用或不活动时，该缓存数据将在这段时间后被垃圾收集。当指定不同的缓存时间时，将使用最长的一个。")]),t._v(" "),a("li",[t._v("如果设置为 Infinity，将禁用垃圾收集")])])]),t._v(" "),a("li",[a("code",[t._v("queryKeyHashFn: (queryKey: QueryKey) => string")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("如果指定，此函数用于将 queryKey 散列为字符串。")])])]),t._v(" "),a("li",[a("code",[t._v("refetchInterval: number |false | ((data:TData | undefined，query: Query)=> number | false)")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("如果设置为一个数字，所有查询将以毫秒为单位以该频率连续重新获取")]),t._v(" "),a("li",[t._v("如果设置为一个函数，该函数将使用最新的数据执行并查询以计算频率")])])]),t._v(" "),a("li",[a("code",[t._v("refetchIntervalInBackground:boolean")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("如果设置为 true，则设置为使用 refetchInterval 连续重新获取的查询将在其选项卡/窗口处于后台时继续重新获取")])])]),t._v(" "),a("li",[a("code",[t._v("refetchOnMount:boolean | 'always' | ((query: Query) => boolean | \"always\")")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("默认为真")]),t._v(" "),a("li",[t._v("如果设置为 true，如果数据过时，查询将在挂载时重新获取。")]),t._v(" "),a("li",[t._v("如果设置为 false，查询将不会在挂载时重新获取。")]),t._v(" "),a("li",[t._v("如果设置为“始终”，查询将始终在挂载时重新获取。")]),t._v(" "),a("li",[t._v("如果设置为一个函数，该函数将与查询一起执行以计算值")])])]),t._v(" "),a("li",[a("code",[t._v("refetchOnWindowFocus:boolean | 'always' | ((query: Query) => boolean | \"always\")")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("默认为真")]),t._v(" "),a("li",[t._v("如果设置为 true，如果数据陈旧，查询将重新获取窗口焦点。")]),t._v(" "),a("li",[t._v("如果设置为 false，查询将不会重新获取窗口焦点。")]),t._v(" "),a("li",[t._v("如果设置为“始终”，查询将始终重新获取窗口焦点。")]),t._v(" "),a("li",[t._v("如果设置为一个函数，该函数将与查询一起执行以计算值")])])]),t._v(" "),a("li",[a("code",[t._v('refetchOnReconnect:boolean | \'always | ((query: Query) => boolean | "always")')]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("默认为真")]),t._v(" "),a("li",[t._v("如果设置为 true，如果数据过时，查询将在重新连接时重新获取。")]),t._v(" "),a("li",[t._v("如果设置为 false，查询将不会在重新连接时重新获取。")]),t._v(" "),a("li",[t._v("如果设置为“始终”，查询将始终在重新连接时重新获取。")]),t._v(" "),a("li",[t._v("如果设置为一个函数，该函数将与查询一起执行以计算值")])])]),t._v(" "),a("li",[a("code",[t._v("notifyOnChangeProps: string[] | 'all'")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("如果设置，组件将仅在任何列出的属性更改时重新渲染。")]),t._v(" "),a("li",[t._v("例如，如果设置为 ['data', 'error']，组件将仅在数据或错误属性更改时重新呈现。")]),t._v(" "),a("li",[t._v("如果设置为“全部”，组件将选择退出智能跟踪并在更新查询时重新呈现。")]),t._v(" "),a("li",[t._v("默认情况下，将跟踪对属性的访问，并且仅当跟踪的属性之一发生更改时，组件才会重新呈现。")])])]),t._v(" "),a("li",[a("code",[t._v("onSuccess: (数据: TData) => void")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("只要查询成功获取新数据，此函数就会触发。")])])]),t._v(" "),a("li",[a("code",[t._v("onError: (error: TError) => void")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("如果查询遇到错误并将传递错误，则此函数将触发。")])])]),t._v(" "),a("li",[a("code",[t._v("onSettled: (data?: TData, error?: TError) => void")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("每当成功获取查询或出错并传递数据或错误时，此函数都会触发。")])])]),t._v(" "),a("li",[a("code",[t._v("select:（数据:TData）=>未知")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("此选项可用于转换或选择查询函数返回的部分数据。它会影响返回的数据值，但不会影响存储在查询缓存中的内容。")])])]),t._v(" "),a("li",[a("code",[t._v("suspense:boolean")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("将此设置为 true 以启用暂停模式。")]),t._v(" "),a("li",[t._v("当 true 时，useQuery 将在 status === 'loading' 时暂停")]),t._v(" "),a("li",[t._v("当 true 时，useQuery 将在 status === 'error' 时抛出运行时错误")])])]),t._v(" "),a("li",[a("code",[t._v("initialData:TData | () => TData")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("如果设置，此值将用作查询缓存的初始数据（只要尚未创建或缓存查询）")]),t._v(" "),a("li",[t._v("如果设置为一个函数，该函数将在共享/根查询初始化期间被调用一次，并期望同步返回 initialData")]),t._v(" "),a("li",[t._v("默认情况下，初始数据被认为是陈旧的，除非设置了 staleTime。")]),t._v(" "),a("li",[t._v("initialData 被持久化到缓存")])])]),t._v(" "),a("li",[a("code",[t._v("initialDataUpdatedAt: number | (() => number | undefined)")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("如果设置，该值将用作上次更新 initialData 本身的时间（以毫秒为单位）。")])])]),t._v(" "),a("li",[a("code",[t._v("placeholderData:TData | () => TData")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("如果设置，当查询仍在加载数据中且未提供 initialData 时，此值将用作此特定查询观察器的占位符数据。")]),t._v(" "),a("li",[t._v("placeholderData 不会持久化到缓存")])])]),t._v(" "),a("li",[a("code",[t._v("keepPreviousData:boolean")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("默认为假"),a("code",[t._v("false")])]),t._v(" "),a("li",[t._v("如果设置，则在获取新数据时将保留任何以前的数据，因为查询键已更改。")])])]),t._v(" "),a("li",[a("code",[t._v("isDataEqual: (oldData: TData | undefined, newData: TData) => boolean")]),t._v(" "),a("ul",[a("li",[t._v("已弃用。您可以通过将函数传递给 structuralSharing 来实现相同的功能:\n"),a("ul",[a("li",[t._v("structuralSharing: (oldData, newData) => isDataEqual(oldData, newData) ?旧数据:replaceEqualDeep（旧数据，新数据）")])])]),t._v(" "),a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("此函数应返回布尔值，指示是使用以前的数据 (true) 还是使用新数据 (false) 作为查询的已解析数据。")])])]),t._v(" "),a("li",[a("code",[t._v("structuralSharing: 布尔 | ((oldData: TData | undefined, newData: TData) => TData)")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("默认为真")]),t._v(" "),a("li",[t._v("如果设置为 false，将禁用查询结果之间的结构共享。")]),t._v(" "),a("li",[t._v("如果设置为一个函数，旧数据值和新数据值将通过该函数传递，该函数应将它们组合成解析数据以供查询。这样，您可以保留旧数据的引用以提高性能，即使该数据包含不可序列化的值也是如此。")])])]),t._v(" "),a("li",[a("code",[t._v("useErrorBoundary:undefined | boolean | (error:TError, query:Query=> boolean")]),t._v(" "),a("ul",[a("li",[t._v("默认为全局查询配置的 useErrorBoundary 值")]),t._v(" "),a("li",[t._v("如果您希望在渲染阶段抛出错误并传播到最近的错误边界，请将此设置为 true")]),t._v(" "),a("li",[t._v("将此设置为 false 以禁用 suspense 将错误抛出到错误边界的默认行为。")]),t._v(" "),a("li",[t._v("如果设置为函数，它将传递错误和查询，它应该返回一个布尔值，指示是在错误边界中显示错误 (true) 还是将错误作为状态返回 (false)")])])]),t._v(" "),a("li",[a("code",[t._v("meta:Record<string, unknown>")]),t._v(" "),a("ul",[a("li",[t._v("可选")]),t._v(" "),a("li",[t._v("如果设置，则存储有关查询缓存条目的附加信息，可根据需要使用。只要查询可用，它就可以访问，它也是提供给 queryFn 的 QueryFunctionContext 的一部分。")])])]),t._v(" "),a("li",[a("code",[t._v("context?:React.Context<QueryClient |undefined>")]),t._v(" "),a("ul",[a("li",[t._v("使用它来使用自定义 React 查询上下文。否则，将使用 defaultContext。")])])])]),t._v(" "),a("p",[a("strong",[t._v("Returns")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("status:String")]),t._v(" "),a("ul",[a("li",[t._v("将:\n"),a("ul",[a("li",[t._v("如果没有缓存数据且查询尝试尚未完成，则加载。")]),t._v(" "),a("li",[t._v("如果查询尝试导致错误，则为错误。相应的错误属性具有从尝试获取中收到的错误")]),t._v(" "),a("li",[t._v("如果查询收到没有错误的响应并准备好显示其数据，则成功。查询上相应的数据属性是从成功获取中接收到的数据，或者如果查询的启用属性设置为 false 并且尚未获取数据，则数据是初始化时提供给查询的第一个 initialData。")])])])])]),t._v(" "),a("li",[a("code",[t._v("isLoading:boolean")]),t._v(" "),a("ul",[a("li",[t._v("为方便起见，从上面的状态变量派生的布尔值。")])])]),t._v(" "),a("li",[a("code",[t._v("isSuccess:boolean")]),t._v(" "),a("ul",[a("li",[t._v("为方便起见，从上面的状态变量派生的布尔值。")])])]),t._v(" "),a("li",[a("code",[t._v("isError:boolean")]),t._v(" "),a("ul",[a("li",[t._v("为方便起见，从上面的状态变量派生的布尔值。")])])]),t._v(" "),a("li",[a("code",[t._v("isLoadingError:boolean")]),t._v(" "),a("ul",[a("li",[t._v("如果第一次获取时查询失败，则为真。")])])]),t._v(" "),a("li",[a("code",[t._v("isRefetchError:boolean")]),t._v(" "),a("ul",[a("li",[t._v("如果查询在重新获取时失败，则为真。")])])]),t._v(" "),a("li",[a("code",[t._v("data:TData")]),t._v(" "),a("ul",[a("li",[t._v("默认为未定义。")]),t._v(" "),a("li",[t._v("查询的最后一次成功解析的数据。")])])]),t._v(" "),a("li",[a("code",[t._v("dataUpdatedAt:number")]),t._v(" "),a("ul",[a("li",[t._v("查询最近返回“成功”状态的时间戳。")])])]),t._v(" "),a("li",[a("code",[t._v("error:null | TError")]),t._v(" "),a("ul",[a("li",[t._v("默认为空")]),t._v(" "),a("li",[t._v("查询的错误对象（如果抛出错误）。")])])]),t._v(" "),a("li",[a("code",[t._v("errorUpdatedAt:number")]),t._v(" "),a("ul",[a("li",[t._v("查询最近一次将状态返回为“错误”的时间戳。")])])]),t._v(" "),a("li",[a("code",[t._v("isStale:boolean")]),t._v(" "),a("ul",[a("li",[t._v("如果缓存中的数据无效或数据早于给定的 staleTime，则为真。")])])]),t._v(" "),a("li",[a("code",[t._v("isPlaceholderData:boolean")]),t._v(" "),a("ul",[a("li",[t._v("如果显示的数据是占位符数据，则为真。")])])]),t._v(" "),a("li",[a("code",[t._v("isPreviousData:boolean")]),t._v(" "),a("ul",[a("li",[t._v("当设置 keepPreviousData 并返回上一个查询的数据时将为真。")])])]),t._v(" "),a("li",[a("code",[t._v("isFetched:boolean")]),t._v(" "),a("ul",[a("li",[t._v("如果已获取查询，则为真。")])])]),t._v(" "),a("li",[a("code",[t._v("isFetchedAfterMount:boolean")]),t._v(" "),a("ul",[a("li",[t._v("如果在安装组件后获取了查询，则为真。")]),t._v(" "),a("li",[t._v("此属性可用于不显示任何以前缓存的数据。")])])]),t._v(" "),a("li",[a("code",[t._v("fetchStatus:获取状态")]),t._v(" "),a("ul",[a("li",[t._v("fetching:每当执行 queryFn 时为真，包括初始加载和后台重新获取。")]),t._v(" "),a("li",[t._v("暂停:查询想要获取，但已暂停。")]),t._v(" "),a("li",[t._v("空闲:查询未获取。")]),t._v(" "),a("li",[t._v("有关详细信息，请参阅网络模式。")])])]),t._v(" "),a("li",[a("code",[t._v("isFetching:boolean")]),t._v(" "),a("ul",[a("li",[t._v("为方便起见，从上面的 fetchStatus 变量派生的布尔值。")])])]),t._v(" "),a("li",[a("code",[t._v("isPaused:boolean")]),t._v(" "),a("ul",[a("li",[t._v("为方便起见，从上面的 fetchStatus 变量派生的布尔值。")])])]),t._v(" "),a("li",[a("code",[t._v("isRefetching:boolean")]),t._v(" "),a("ul",[a("li",[t._v("每当后台重新获取正在进行时为真，这不包括初始加载")]),t._v(" "),a("li",[t._v("与 isFetching && !isLoading 相同")])])]),t._v(" "),a("li",[a("code",[t._v("isInitialLoading:boolean")]),t._v(" "),a("ul",[a("li",[t._v("每当查询的第一次提取正在进行中时为真")]),t._v(" "),a("li",[t._v("与 isFetching && isLoading 相同")])])]),t._v(" "),a("li",[a("code",[t._v("failureCount:number")]),t._v(" "),a("ul",[a("li",[t._v("查询的失败计数。")]),t._v(" "),a("li",[t._v("每次查询失败时递增。")]),t._v(" "),a("li",[t._v("查询成功时重置为 0。")])])]),t._v(" "),a("li",[a("code",[t._v("failureReason:null | TError")]),t._v(" "),a("ul",[a("li",[t._v("查询重试的失败原因。")]),t._v(" "),a("li",[t._v("查询成功时重置为空。")])])]),t._v(" "),a("li",[a("code",[t._v("errorUpdateCount: number")]),t._v(" "),a("ul",[a("li",[t._v("所有错误的总和。")])])]),t._v(" "),a("li",[a("code",[t._v("refetch:(options:{throwOnError:boolean，cancelRefetch:boolean}) => Promise <UseQueryResult>")]),t._v(" "),a("ul",[a("li",[t._v("手动重新获取查询的函数。")]),t._v(" "),a("li",[t._v("如果查询出错，则只会记录错误。如果要抛出错误，请传递 throwOnError: true 选项")]),t._v(" "),a("li",[a("code",[t._v("cancelRefetch?: boolean")]),t._v(" "),a("ul",[a("li",[t._v("默认为真\n"),a("ul",[a("li",[t._v("默认情况下，当前正在运行的请求将在发出新请求之前被取消")])])]),t._v(" "),a("li",[t._v("当设置为 false 时，如果已经有请求正在运行，则不会重新获取。")])])])])]),t._v(" "),a("li",[a("code",[t._v("remove:（）=>void")]),t._v(" "),a("ul",[a("li",[t._v("从缓存中删除查询的函数。")])])])]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tanstack/query/tree/main/docs/react/reference/useQuery.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("在 GitHub 上编辑"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);